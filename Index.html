/**
 * ============================================
 * ELIROX BOT - REGISTRATION BACKEND
 * Google Apps Script - Production Version with Update Status
 * ============================================
 * 
 * X·ª≠ l√Ω ƒëƒÉng k√Ω t·ª´:
 * - Web form: https://tool.eliroxbot.com
 * - Telegram Bot: @EliroxBot
 * 
 * UPDATED: Added update_status action for bot integration
 * Last updated: 2026-01-24
 */

// ============================================
// CONFIGURATION
// ============================================

const CONFIG = {
  SHEET_NAME: 'Registrations',
  DEFAULT_STATUS: 'Ch·ªù duy·ªát',
  TIMEZONE: 'Asia/Ho_Chi_Minh',
  
  // Column mapping (0-based index)
  COLUMNS: {
    DATE: 0,        // A: üìÖ Ng√†y ƒëƒÉng k√Ω
    NAME: 1,        // B: H·ªç & T√™n
    TELEGRAM: 2,    // C: üë§ Telegram
    EMAIL: 3,       // D: üìß Email
    SOURCE: 4,      // E: üìç Ngu·ªìn
    STATUS: 5       // F: üìä Tr·∫°ng th√°i
  },
  
  // Column headers
  HEADERS: [
    'üìÖ Ng√†y ƒëƒÉng k√Ω',
    'H·ªç & T√™n',
    'üë§ Telegram',
    'üìß Email',
    'üìç Ngu·ªìn',
    'üìä Tr·∫°ng th√°i'
  ]
};

// ============================================
// MAIN HANDLERS
// ============================================

/**
 * Handle GET requests - L·∫•y danh s√°ch registrations
 */
function doGet(e) {
  try {
    const sheet = getOrCreateSheet();
    const data = sheet.getDataRange().getValues();
    
    // Skip header row
    const headers = data[0];
    const result = [];
    
    for (let i = 1; i < data.length; i++) {
      const row = {};
      for (let j = 0; j < headers.length; j++) {
        row[headers[j]] = data[i][j];
      }
      result.push(row);
    }
    
    return createResponse(true, 'Data fetched successfully', result);
    
  } catch (error) {
    logError('doGet', error);
    return createResponse(false, 'Server error: ' + error.message);
  }
}

/**
 * Handle POST requests - Th√™m registration m·ªõi HO·∫∂C c·∫≠p nh·∫≠t tr·∫°ng th√°i
 */
function doPost(e) {
  try {
    // Parse request body
    const data = parseRequestData(e);
    
    // ============================================
    // NEW: Handle update_status action from bot
    // ============================================
    if (data.action === 'update_status') {
      logInfo('doPost', `Update status request for email: ${data.email}, status: ${data.status}`);
      
      if (!data.email || !data.status) {
        return createResponse(false, 'Missing email or status for update');
      }
      
      const updateResult = updateUserStatus(data.email, data.status);
      
      if (updateResult.success) {
        return createResponse(true, updateResult.message);
      } else {
        return createResponse(false, updateResult.message);
      }
    }
    
    // ============================================
    // Original registration logic
    // ============================================
    
    // TEMPORARILY DISABLE VALIDATION FOR DEBUGGING
    // const validation = validateInput(data);
    // if (!validation.valid) {
    //   return createResponse(false, validation.message);
    // }
    
    // Log received data for debugging
    logInfo('doPost', `Received registration: ${JSON.stringify(data)}`);
    
    // Check for duplicates (only email to avoid blocking)
    if (data.email) {
      const duplicate = checkDuplicate(data.email, data.telegram);
      if (duplicate.exists) {
        return createResponse(false, duplicate.message);
      }
    }
    
    // Add to sheet
    const result = addRegistration(data);
    
    if (result.success) {
      // Get sheet info for debugging
      const sheet = getOrCreateSheet();
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      
      return createResponse(true, 'ƒêƒÉng k√Ω th√†nh c√¥ng! Ch√∫ng t√¥i s·∫Ω li√™n h·ªá b·∫°n trong v√≤ng 24h.', {
        rowNumber: result.rowNumber,
        receivedData: data,  // Return what was received for debugging
        sheetInfo: {
          spreadsheetName: spreadsheet.getName(),
          spreadsheetId: spreadsheet.getId(),
          sheetName: sheet.getName(),
          totalRows: sheet.getLastRow(),
          url: spreadsheet.getUrl()
        }
      });
    } else {
      return createResponse(false, 'Kh√¥ng th·ªÉ l∆∞u d·ªØ li·ªáu: ' + result.error);
    }
    
  } catch (error) {
    logError('doPost', error);
    return createResponse(false, 'L·ªói h·ªá th·ªëng: ' + error.message);
  }
}

// ============================================
// CORE FUNCTIONS
// ============================================

/**
 * Get or create sheet with proper headers
 */
function getOrCreateSheet() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
  
  // Create sheet if not exists
  if (!sheet) {
    sheet = spreadsheet.insertSheet(CONFIG.SHEET_NAME);
    
    // Set headers
    const headerRange = sheet.getRange(1, 1, 1, CONFIG.HEADERS.length);
    headerRange.setValues([CONFIG.HEADERS]);
    
    // Format headers
    headerRange
      .setFontWeight('bold')
      .setBackground('#4285f4')
      .setFontColor('#ffffff')
      .setHorizontalAlignment('center');
    
    // Freeze header row
    sheet.setFrozenRows(1);
    
    // Auto-resize columns
    for (let i = 1; i <= CONFIG.HEADERS.length; i++) {
      sheet.autoResizeColumn(i);
    }
  }
  
  return sheet;
}

/**
 * Parse request data from POST
 */
function parseRequestData(e) {
  try {
    if (!e || !e.postData) {
      throw new Error('No POST data received');
    }
    
    const contentType = e.postData.type;
    const rawContent = e.postData.contents;
    let data;
    
    // Log for debugging
    logInfo('parseRequestData', `Content-Type: ${contentType}`);
    
    // Parse JSON regardless of content type
    try {
      data = JSON.parse(rawContent);
    } catch (parseError) {
      logError('parseRequestData', `JSON parse failed: ${parseError.message}`);
      throw new Error('Invalid JSON format');
    }
    
    // Check if this is an update_status request (different structure)
    if (data.action === 'update_status') {
      logInfo('parseRequestData', `Parsed update_status: ${JSON.stringify(data)}`);
      return {
        action: 'update_status',
        telegram_id: data.telegram_id,
        email: (data.email || '').trim().toLowerCase(),
        status: data.status || 'Approved'
      };
    }
    
    // Validate required fields for registration
    if (!data.email) {
      throw new Error('Missing required field: email');
    }
    
    return {
      fullName: (data.fullName || data.name || '').trim(),
      telegram: (data.telegram || '').trim(),
      email: (data.email || '').trim().toLowerCase(),
      source: (data.source || 'Web Form').trim()
    };
    
  } catch (error) {
    logError('parseRequestData', error);
    throw new Error('Invalid request format: ' + error.message);
  }
}

/**
 * Validate input data
 */
function validateInput(data) {
  // Check required fields
  if (!data.email || data.email.length === 0) {
    return { valid: false, message: 'Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng' };
  }
  
  if (!data.telegram || data.telegram.length === 0) {
    return { valid: false, message: 'Telegram kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng' };
  }
  
  if (!data.fullName || data.fullName.length === 0) {
    return { valid: false, message: 'H·ªç t√™n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng' };
  }
  
  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(data.email)) {
    return { valid: false, message: 'Email kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng' };
  }
  
  // Validate Telegram format (should start with @ or be username)
  if (data.telegram && !data.telegram.startsWith('@')) {
    data.telegram = '@' + data.telegram;
  }
  
  return { valid: true };
}

/**
 * Check for duplicate registrations
 */
function checkDuplicate(email, telegram) {
  const sheet = getOrCreateSheet();
  const data = sheet.getDataRange().getValues();
  
  // Skip header row
  for (let i = 1; i < data.length; i++) {
    const rowEmail = String(data[i][CONFIG.COLUMNS.EMAIL]).toLowerCase().trim();
    const rowTelegram = String(data[i][CONFIG.COLUMNS.TELEGRAM]).toLowerCase().trim();
    
    // Check email duplicate
    if (rowEmail === email.toLowerCase()) {
      return {
        exists: true,
        message: 'Email n√†y ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω. Vui l√≤ng ki·ªÉm tra l·∫°i ho·∫∑c li√™n h·ªá support.'
      };
    }
    
    // Check telegram duplicate
    if (rowTelegram === telegram.toLowerCase()) {
      return {
        exists: true,
        message: 'Telegram n√†y ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω. Vui l√≤ng ki·ªÉm tra l·∫°i ho·∫∑c li√™n h·ªá support.'
      };
    }
  }
  
  return { exists: false };
}

/**
 * Add registration to sheet
 */
function addRegistration(data) {
  try {
    const sheet = getOrCreateSheet();
    
    // LOG: Input data
    logInfo('addRegistration', `Input data: ${JSON.stringify(data)}`);
    
    // Generate registration date (Vietnam timezone)
    const registrationDate = Utilities.formatDate(
      new Date(),
      CONFIG.TIMEZONE,
      'dd/MM/yyyy HH:mm:ss'
    );
    
    // Prepare row data
    const rowData = [
      registrationDate,              // A: Ng√†y ƒëƒÉng k√Ω
      data.fullName,                 // B: H·ªç & T√™n
      data.telegram,                 // C: Telegram
      data.email,                    // D: Email
      data.source,                   // E: Ngu·ªìn
      CONFIG.DEFAULT_STATUS          // F: Tr·∫°ng th√°i
    ];
    
    // LOG: Row data before insert
    logInfo('addRegistration', `Row data: ${JSON.stringify(rowData)}`);
    
    // Append to sheet
    sheet.appendRow(rowData);
    const lastRow = sheet.getLastRow();
    
    // LOG: After insert
    logInfo('addRegistration', `Inserted at row: ${lastRow}`);
    
    // Format the new row
    const rowRange = sheet.getRange(lastRow, 1, 1, rowData.length);
    rowRange.setHorizontalAlignment('left');
    
    // LOG: Verify what was written
    const writtenData = sheet.getRange(lastRow, 1, 1, rowData.length).getValues()[0];
    logInfo('addRegistration', `Written to sheet: ${JSON.stringify(writtenData)}`);
    
    return {
      success: true,
      rowNumber: lastRow
    };
    
  } catch (error) {
    logError('addRegistration', error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Update user status in sheet (NEW - for bot integration)
 * T√¨m user theo EMAIL v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i
 */
function updateUserStatus(email, newStatus) {
  try {
    const sheet = getOrCreateSheet();
    const data = sheet.getDataRange().getValues();
    
    const emailLower = email.toLowerCase().trim();
    logInfo('updateUserStatus', `Searching for email: ${emailLower}, new status: ${newStatus}`);
    logInfo('updateUserStatus', `Total rows in sheet: ${data.length}`);
    
    // Find user by email (skip header row)
    for (let i = 1; i < data.length; i++) {
      const rowEmail = String(data[i][CONFIG.COLUMNS.EMAIL]).toLowerCase().trim();
      
      logInfo('updateUserStatus', `Row ${i}: Comparing "${rowEmail}" with "${emailLower}"`);
      
      if (rowEmail === emailLower) {
        // Update status column (F: Tr·∫°ng th√°i)
        const statusCell = sheet.getRange(i + 1, CONFIG.COLUMNS.STATUS + 1);
        const oldStatus = statusCell.getValue();
        statusCell.setValue(newStatus);
        
        logInfo('updateUserStatus', `‚úÖ Updated row ${i + 1}: ${oldStatus} -> ${newStatus}`);
        
        return {
          success: true,
          message: `C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng cho ${email}`
        };
      }
    }
    
    // Not found
    logInfo('updateUserStatus', `‚ùå Email not found: ${emailLower}`);
    return {
      success: false,
      message: `Kh√¥ng t√¨m th·∫•y user v·ªõi email: ${email}`
    };
    
  } catch (error) {
    logError('updateUserStatus', error);
    return {
      success: false,
      message: `L·ªói khi c·∫≠p nh·∫≠t: ${error.message}`
    };
  }
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

/**
 * Create standardized JSON response
 */
function createResponse(success, message, data = null) {
  const response = {
    success: success,
    status: success ? 'success' : 'error',
    message: message,
    timestamp: new Date().toISOString()
  };
  
  if (data) {
    response.data = data;
  }
  
  return ContentService
    .createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Log information
 */
function logInfo(functionName, message) {
  console.log(`[INFO] ${functionName}: ${message}`);
  Logger.log(`[INFO] ${functionName}: ${message}`);
}

/**
 * Log error
 */
function logError(functionName, error) {
  console.error(`[ERROR] ${functionName}: ${error.message || error}`);
  Logger.log(`[ERROR] ${functionName}: ${error.message || error}`);
}

// ============================================
// ADMIN FUNCTIONS (Optional - for manual testing)
// ============================================

/**
 * Test function - Add sample data
 */
function testAddSample() {
  const testData = {
    fullName: 'Nguy·ªÖn VƒÉn Test',
    telegram: '@testuser',
    email: 'test' + Date.now() + '@example.com',
    source: 'Manual Test'
  };
  
  const result = addRegistration(testData);
  Logger.log('Test result: ' + JSON.stringify(result));
}

/**
 * Test function - Update status
 */
function testUpdateStatus() {
  const result = updateUserStatus('mettatuan@gmail.com', 'Approved');
  Logger.log('Update result: ' + JSON.stringify(result));
}

/**
 * Get all registrations (for debugging)
 */ 
function getAllRegistrations() {
  const sheet = getOrCreateSheet();
  const data = sheet.getDataRange().getValues();
  
  Logger.log('Total rows: ' + (data.length - 1)); // Exclude header
  
  for (let i = 1; i < Math.min(6, data.length); i++) { // Show first 5 rows
    Logger.log(`Row ${i}: ${JSON.stringify(data[i])}`);
  }
}

/**
 * Clear all data (DANGEROUS - use carefully)
 */
function clearAllData() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert(
    'X√°c nh·∫≠n x√≥a d·ªØ li·ªáu',
    'B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a T·∫§T C·∫¢ d·ªØ li·ªáu? H√†nh ƒë·ªông n√†y KH√îNG TH·ªÇ ho√†n t√°c!',
    ui.ButtonSet.YES_NO
  );
  
  if (response === ui.Button.YES) {
    const sheet = getOrCreateSheet();
    const lastRow = sheet.getLastRow();
    
    if (lastRow > 1) {
      sheet.deleteRows(2, lastRow - 1);
      ui.alert('ƒê√£ x√≥a ' + (lastRow - 1) + ' d√≤ng d·ªØ li·ªáu');
    } else {
      ui.alert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ x√≥a');
    }
  }
}

// ============================================
// DEPLOYMENT INSTRUCTIONS
// ============================================

/**
 * H∆Ø·ªöNG D·∫™N DEPLOY:
 * 
 * 1. M·ªü Google Sheet c·ªßa b·∫°n
 * 2. Extensions ‚Üí Apps Script
 * 3. X√≥a code m·∫´u, paste to√†n b·ªô code n√†y
 * 4. Click "Deploy" ‚Üí "New deployment"
 * 5. C√†i ƒë·∫∑t:
 *    - Type: Web app
 *    - Execute as: Me
 *    - Who has access: Anyone
 * 6. Click "Deploy"
 * 7. Copy URL web app ‚Üí C·∫≠p nh·∫≠t v√†o frontend & bot
 * 
 * TEST REGISTRATION:
 * curl -X POST "YOUR_SCRIPT_URL" \
 *   -H "Content-Type: application/json" \
 *   -d '{
 *     "fullName": "Test User",
 *     "telegram": "@testuser",
 *     "email": "test@example.com",
 *     "source": "Web Form"
 *   }'
 * 
 * TEST UPDATE STATUS:
 * curl -X POST "YOUR_SCRIPT_URL" \
 *   -H "Content-Type: application/json" \
 *   -d '{
 *     "action": "update_status",
 *     "email": "mettatuan@gmail.com",
 *     "status": "Approved",
 *     "telegram_id": "1299465308"
 *   }'
 */
